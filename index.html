<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1.0,maximum-scale=1.0,user-scalable=no,viewport-fit=cover">
  <title>TrdMax</title>

  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;800&display=swap" rel="stylesheet">
  <script src="https://telegram.org/js/telegram-web-app.js"></script>

  <style>
    /* =========================================================
       TrdMax — 2026 Premium Mini App Home (Black / Green / Red)
       - Buttons untouched
       - Animated background: aurora + market wave + particles + grid
       ========================================================= */

    * { margin: 0; padding: 0; box-sizing: border-box; font-family: 'Inter', sans-serif }
    html, body { height: 100% }
    html,body{
      touch-action: manipulation;
    }

    :root {
      /* safe areas (Telegram) */
      --sa-top: var(--tg-safe-area-inset-top, 0px);
      --sa-right: var(--tg-safe-area-inset-right, 0px);
      --sa-bottom: var(--tg-safe-area-inset-bottom, 0px);
      --sa-left: var(--tg-safe-area-inset-left, 0px);

      --csa-top: var(--tg-content-safe-area-inset-top, 0px);
      --csa-right: var(--tg-content-safe-area-inset-right, 0px);
      --csa-bottom: var(--tg-content-safe-area-inset-bottom, 0px);
      --csa-left: var(--tg-content-safe-area-inset-left, 0px);

      /* palette */
      --black: #000;
      --card: rgba(15, 15, 15, .55);
      --text: #fff;

      /* accents */
      --g: rgba(0, 255, 136, 1);
      --gSoft: rgba(0, 255, 136, .22);
      --gSoft2: rgba(0, 255, 136, .12);
      --r: rgba(255, 0, 60, 1);
      --rSoft: rgba(255, 0, 60, .18);
    }

    body {
      min-height: 100vh;
      display: flex;
      align-items: center;
      justify-content: center;
      background: var(--black);
      color: var(--text);
      overflow: hidden;
      -webkit-tap-highlight-color: transparent;

      padding:
        calc(var(--sa-top) + var(--csa-top))
        calc(var(--sa-right) + var(--csa-right))
        calc(var(--sa-bottom) + var(--csa-bottom))
        calc(var(--sa-left) + var(--csa-left));
    }

    /* =========================
       BACKGROUND CANVAS STACK
       ========================= */
    .bg {
      position: fixed;
      inset: 0;
      z-index: -10;
      background: #000;
      pointer-events: none;
      overflow: hidden;
    }

    /* One canvas (all layers drawn in JS for performance + control) */
    #fx {
      position: absolute;
      inset: 0;
      width: 100%;
      height: 100%;
      display: block;
    }

    /* vignette & subtle film grain overlay (pure CSS) */
    .vignette {
      position: absolute;
      inset: -10%;
      background:
        radial-gradient(1200px 800px at 50% 45%, rgba(0, 0, 0, .0), rgba(0, 0, 0, .65) 70%, rgba(0, 0, 0, .90) 100%);
      opacity: 1;
      mix-blend-mode: multiply;
    }

    .grain {
      position: absolute;
      inset: 0;
      opacity: .045;
      background-image:
        url('https://grainy-gradients.vercel.app/noise.svg');
      mix-blend-mode: overlay;
      filter: contrast(120%);
    }

    /* =========================
       CONTAINER (premium glass)
       ========================= */
    .container {
      position: relative;
      width: 340px;
      padding: 50px 40px;
      border-radius: 28px;

      background: var(--card);
      backdrop-filter: blur(50px) saturate(160%);
      -webkit-backdrop-filter: blur(50px) saturate(160%);

      border: 1px solid rgba(255, 255, 255, .08);
      box-shadow:
        0 2px 8px rgba(0, 0, 0, .4),
        0 30px 80px rgba(0, 0, 0, .6),
        0 0 60px rgba(0, 255, 136, .07);

      opacity: 0;
      transform: translateY(54px) scale(.95);
      animation: cardIn 980ms cubic-bezier(.16, 1, .3, 1) forwards;
      will-change: transform, opacity;
    }

    .container::before {
      content: "";
      position: absolute;
      inset: 0;
      border-radius: 28px;
      background:
        radial-gradient(circle at 20% 15%, rgba(255, 255, 255, .09), transparent 60%),
        radial-gradient(circle at 90% 90%, rgba(0, 255, 136, .06), transparent 55%);
      pointer-events: none;
    }

    .container::after {
      content: "";
      position: absolute;
      inset: 1px;
      border-radius: 27px;
      border: 1px solid rgba(255, 255, 255, .05);
      pointer-events: none;
    }

    @keyframes cardIn {
      0% { opacity: 0; transform: translateY(54px) scale(.95); filter: blur(10px) }
      70% { opacity: 1; transform: translateY(0) scale(1.02); filter: blur(0) }
      100% { opacity: 1; transform: translateY(0) scale(1); filter: blur(0) }
    }

    /* =========================
       LOGO
       ========================= */
    .logo-wrap{
      display:flex;
      align-items:center;
      justify-content:center;
      gap:10px;
      margin-bottom:10px; /* Adjust margin as needed */
    }

    .logo-symbol{
      width:14px;
      height:14px;
      border:2px solid rgba(0,255,136,.7);
      border-radius:4px;
      transform:rotate(45deg);
      box-shadow:0 0 12px rgba(0,255,136,.3);
    }

    .logo{
      font-size:36px;
      font-weight:800;
      letter-spacing:1px;
      text-align:center;

      background: linear-gradient(90deg, rgba(0, 255, 136, 1), rgba(255, 0, 60, 1));
      background-size: 200% 100%;
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;

      animation: shimmer 6.5s linear infinite;
      text-shadow:
        0 0 16px rgba(0, 255, 136, .20),
        0 0 34px rgba(255, 0, 60, .10);
      transform: translateZ(0);
    }
    @keyframes shimmer {
      0% { background-position: 0% 50% }
      100% { background-position: 200% 50% }
    }

    .subtitle {
      text-align: center;
      opacity: .62;
      margin: 10px 0 35px;
      font-size: 14px;
      letter-spacing: .2px;
    }

    /* =========================
       DIVIDER
       ========================= */
    .divider{
      height:1px;
      margin:20px 0 25px;
      background:linear-gradient(
        90deg,
        transparent,
        rgba(255,255,255,.12),
        transparent
      );
      opacity:.4;
    }

    /* =========================
       SYSTEM STATUS
       ========================= */
    .system-status{
      position:absolute;
      top:14px;
      right:18px;
      font-size:11px;
      opacity:.55;
      display:flex;
      align-items:center;
      gap:6px;
      letter-spacing:.5px;
    }

    .system-status::before{
      content:"";
      width:6px;
      height:6px;
      border-radius:50%;
      background:#00ff88;
      box-shadow:0 0 8px rgba(0,255,136,.6);
    }


    /* =========================================================
       ✅ BUTTONS — UNTOUCHED (exactly as your version)
       ========================================================= */
    .btn {
      width: 100%;
      padding: 16px;
      margin-bottom: 15px;
      border-radius: 18px;
      background: rgba(255, 255, 255, .04);
      border: 1px solid rgba(255, 255, 255, .08);
      color: #fff;
      font-weight: 600;
      cursor: pointer;
      transition: .3s;
      position: relative;
      overflow: hidden;
    }

    .btn::before {
      content: "";
      position: absolute;
      top: 0;
      left: -100%;
      width: 100%;
      height: 100%;
      background: linear-gradient(90deg, transparent, rgba(255, 255, 255, .2), transparent);
      transition: .6s;
    }

    .btn:hover::before { left: 100% }

    .btn:hover {
      background: rgba(255, 255, 255, .08);
      box-shadow: 0 0 40px rgba(0, 255, 136, .25);
      transform: translateY(-3px);
    }

    .btn:active { transform: scale(.97) }

    /* =========================
       BUTTON HIERARCHY
       ========================= */
    .btn:first-of-type {
      background: rgba(0, 255, 136, .08);
      box-shadow:
        0 0 25px rgba(0, 255, 136, .25),
        inset 0 0 10px rgba(0, 255, 136, .08);
    }

    .btn:first-of-type:hover {
      box-shadow:
        0 0 45px rgba(0, 255, 136, .35),
        inset 0 0 14px rgba(0, 255, 136, .15);
    }


    /* =========================
       CARD LIGHT REACTION
       ========================= */
    .container.light-active {
      box-shadow:
        0 2px 8px rgba(0, 0, 0, .4),
        0 30px 80px rgba(0, 0, 0, .6),
        0 0 80px rgba(0, 255, 136, .12);
    }


    /* =========================
       Reduced motion support
       ========================= */
    @media (prefers-reduced-motion: reduce) {
      .container,
      .logo { animation: none !important }
      .container { opacity: 1; transform: none; filter: none }
      .grain { opacity: .02 }
    }
  </style>
</head>

<body>
  <div class="bg">
    <canvas id="fx"></canvas>
    <div class="vignette"></div>
    <div class="grain"></div>
  </div>

  <div class="container" id="card">
    <div class="logo-wrap">
      <div class="logo-symbol"></div>
      <div class="logo">TrdMax</div>
    </div>
    <div class="subtitle">Premium Trading Platform</div>

    <div class="divider"></div>

    <div class="system-status">System Online</div>

    <button class="btn">Начать</button>
    <button class="btn">О проекте</button>
    <button class="btn">Поддержка</button>
  </div>

  <script>
    /* =========================================================
       Telegram Mini App setup
       ========================================================= */
    (function initTelegram() {
      const tg = window.Telegram?.WebApp;
      if (!tg) return;

      try {
        tg.ready();
        tg.expand();
        tg.enableVerticalSwipes?.();

        tg.setHeaderColor?.('#000000');
        tg.setBackgroundColor?.('#000000');
        tg.setBottomBarColor?.('#000000');
      } catch (e) {}

      // haptics on buttons
      document.querySelectorAll('.btn').forEach(btn => {
        btn.addEventListener('click', () => {
          try { tg.HapticFeedback?.impactOccurred('light'); } catch (e) {}
        }, { passive: true });
      });
    })();

    /* =========================================================
       FX Background Engine (Canvas)
       - Subtle "Market Wave" + Aurora blobs + Particles + Grid
       - Adaptive quality for smoothness
       ========================================================= */

    (function FX() {
      const canvas = document.getElementById('fx');
      const ctx = canvas.getContext('2d', { alpha: true });

      const prefersReducedMotion = window.matchMedia('(prefers-reduced-motion: reduce)').matches;

      // Quality presets (auto)
      const Q = {
        scale: 1,               // internal render scale
        fpsCap: 60,             // dynamic
        particles: 70,          // count
        blobs: 4,               // aurora blobs
        gridAlpha: 0.06,        // subtle
        waveAlpha: 0.14,        // subtle
        auraAlpha: 0.18,        // subtle
      };

      // Very conservative defaults for iPhone WebView (still looks premium)
      // If reduced motion: freeze background
      if (prefersReducedMotion) {
        Q.fpsCap = 0;
        Q.particles = 0;
        Q.blobs = 0;
        Q.gridAlpha = 0.03;
        Q.waveAlpha = 0.10;
        Q.auraAlpha = 0.10;
      }

      // Device / performance heuristics
      const ua = navigator.userAgent || '';
      const isIOS = /iPhone|iPad|iPod/i.test(ua);
      const isTelegram = /Telegram/i.test(ua);

      // On iOS Telegram WebView: keep it smooth
      if (isIOS && isTelegram) {
        Q.scale = 1;
        Q.particles = prefersReducedMotion ? 0 : 55;
        Q.blobs = prefersReducedMotion ? 0 : 3;
      }

      // Resize
      let W = 0, H = 0, DPR = 1;

      function resize() {
        DPR = Math.min(2, window.devicePixelRatio || 1);
        const scale = Q.scale;

        W = Math.floor(window.innerWidth);
        H = Math.floor(window.innerHeight);

        canvas.width = Math.floor(W * DPR * scale);
        canvas.height = Math.floor(H * DPR * scale);

        canvas.style.width = W + 'px';
        canvas.style.height = H + 'px';

        ctx.setTransform(1, 0, 0, 1, 0, 0);
        ctx.scale(DPR * scale, DPR * scale);
      }
      resize();
      window.addEventListener('resize', resize);

      // ---------------------------------------------------------
      // Helpers
      // ---------------------------------------------------------
      function clamp(v, a, b) { return Math.max(a, Math.min(b, v)); }

      function lerp(a, b, t) { return a + (b - a) * t; }

      function rand(min, max) { return min + Math.random() * (max - min); }

      function now() { return performance.now(); }

      // Color helpers: we use rgba strings for simplicity
      const COLORS = {
        green: 'rgba(0,255,136,',
        red:   'rgba(255,0,60,',
        white: 'rgba(255,255,255,',
        black: 'rgba(0,0,0,'
      };

      // ---------------------------------------------------------
      // Particles (slow floating dust / bokeh)
      // ---------------------------------------------------------
      const particles = [];
      function spawnParticles() {
        particles.length = 0;
        for (let i = 0; i < Q.particles; i++) {
          particles.push({
            x: rand(0, W),
            y: rand(0, H),
            r: rand(0.6, 2.2),
            vx: rand(-0.06, 0.06),
            vy: rand(-0.04, 0.04),
            a: rand(0.05, 0.18),
            g: Math.random() > 0.92, // rare green bokeh
          });
        }
      }
      spawnParticles();

      // ---------------------------------------------------------
      // Aurora blobs (very soft moving light fog)
      // ---------------------------------------------------------
      const blobs = [];
      function spawnBlobs() {
        blobs.length = 0;
        for (let i = 0; i < Q.blobs; i++) {
          const isRed = (i === 0); // only one blob is red-ish
          blobs.push({
            x: rand(W * 0.15, W * 0.85),
            y: rand(H * 0.20, H * 0.80),
            r: rand(Math.min(W, H) * 0.22, Math.min(W, H) * 0.40),
            vx: rand(-0.10, 0.10),
            vy: rand(-0.08, 0.08),
            t: rand(0, 1000),
            red: isRed
          });
        }
      }
      spawnBlobs();

      // ---------------------------------------------------------
      // Market wave (stylized, not literal)
      // - Green line + rare red spike “pulse”
      // ---------------------------------------------------------
      let wavePhase = rand(0, 1000);
      let spike = 0;          // spike intensity 0..1
      let spikeTarget = 0;
      let spikeTimer = rand(3000, 9000);

      function updateSpike(dt) {
        spikeTimer -= dt;
        if (spikeTimer <= 0) {
          spikeTarget = (Math.random() > 0.55) ? rand(0.35, 0.9) : 0; // sometimes no spike
          spikeTimer = rand(5000, 12000);
        }
        spike = lerp(spike, spikeTarget, 0.02);
        if (spikeTarget > 0.01 && spike > 0.80) {
          spikeTarget = 0; // decay after peak
        }
      }

      // ---------------------------------------------------------
      // Grid (subtle tech feel)
      // ---------------------------------------------------------
      function drawGrid() {
        ctx.save();
        ctx.globalAlpha = Q.gridAlpha;

        const step = 44; // px
        ctx.lineWidth = 1;

        // Very subtle green-ish grid
        ctx.strokeStyle = COLORS.green + '0.12)';
        for (let x = 0; x <= W; x += step) {
          ctx.beginPath();
          ctx.moveTo(x, 0);
          ctx.lineTo(x, H);
          ctx.stroke();
        }

        ctx.strokeStyle = COLORS.white + '0.06)';
        for (let y = 0; y <= H; y += step) {
          ctx.beginPath();
          ctx.moveTo(0, y);
          ctx.lineTo(W, y);
          ctx.stroke();
        }

        ctx.restore();
      }

      // ---------------------------------------------------------
      // Background base (deep black + slight gradient)
      // ---------------------------------------------------------
      function drawBase() {
        const g = ctx.createRadialGradient(W * 0.5, H * 0.45, 0, W * 0.5, H * 0.45, Math.max(W, H) * 0.85);
        g.addColorStop(0, 'rgba(0,0,0,1)');
        g.addColorStop(0.65, 'rgba(0,0,0,1)');
        g.addColorStop(1, 'rgba(0,0,0,1)');
        ctx.fillStyle = g;
        ctx.fillRect(0, 0, W, H);
      }

      // ---------------------------------------------------------
      // Aurora / fog
      // ---------------------------------------------------------
      function drawAurora(dt) {
        ctx.save();
        ctx.globalCompositeOperation = 'lighter';
        ctx.globalAlpha = Q.auraAlpha;

        for (const b of blobs) {
          // move slowly
          b.t += dt * 0.001;
          b.x += b.vx * dt * 0.02;
          b.y += b.vy * dt * 0.02;

          // soft boundary bounce
          if (b.x < -b.r * 0.2) b.x = W + b.r * 0.2;
          if (b.x > W + b.r * 0.2) b.x = -b.r * 0.2;
          if (b.y < -b.r * 0.2) b.y = H + b.r * 0.2;
          if (b.y > H + b.r * 0.2) b.y = -b.r * 0.2;

          // breathe radius slightly
          const rr = b.r * (0.92 + 0.10 * Math.sin(b.t * 0.35));

          const grad = ctx.createRadialGradient(b.x, b.y, rr * 0.12, b.x, b.y, rr);
          if (b.red) {
            // red blob is rarer and dimmer (premium rule)
            grad.addColorStop(0, 'rgba(255,0,60,0.22)');
            grad.addColorStop(0.55, 'rgba(255,0,60,0.06)');
            grad.addColorStop(1, 'rgba(255,0,60,0.00)');
          } else {
            grad.addColorStop(0, 'rgba(0,255,136,0.24)');
            grad.addColorStop(0.60, 'rgba(0,255,136,0.07)');
            grad.addColorStop(1, 'rgba(0,255,136,0.00)');
          }

          ctx.fillStyle = grad;
          ctx.beginPath();
          ctx.arc(b.x, b.y, rr, 0, Math.PI * 2);
          ctx.fill();
        }

        ctx.restore();

        // extra blur impression (cheap blur alternative: draw semi-transparent black veil)
        ctx.save();
        ctx.globalAlpha = 0.08;
        ctx.fillStyle = 'rgba(0,0,0,1)';
        ctx.fillRect(0, 0, W, H);
        ctx.restore();
      }

      // ---------------------------------------------------------
      // Particles
      // ---------------------------------------------------------
      function drawParticles(dt) {
        if (Q.particles <= 0) return;

        ctx.save();
        ctx.globalCompositeOperation = 'screen';

        for (const p of particles) {
          p.x += p.vx * dt;
          p.y += p.vy * dt;

          // wrap
          if (p.x < -10) p.x = W + 10;
          if (p.x > W + 10) p.x = -10;
          if (p.y < -10) p.y = H + 10;
          if (p.y > H + 10) p.y = -10;

          // faint twinkle
          const tw = 0.6 + 0.4 * Math.sin((p.x + p.y) * 0.002 + wavePhase * 0.001);

          const alpha = clamp(p.a * tw, 0.03, 0.22);
          const color = p.g ? COLORS.green + alpha + ')' : COLORS.white + (alpha * 0.55) + ')';

          ctx.fillStyle = color;
          ctx.beginPath();
          ctx.arc(p.x, p.y, p.r, 0, Math.PI * 2);
          ctx.fill();
        }

        ctx.restore();
      }

      // ---------------------------------------------------------
      // Market wave (main “wow” element)
      // ---------------------------------------------------------
      function drawMarketWave(dt) {
        wavePhase += dt * 0.001;
        updateSpike(dt);

        const midY = H * 0.55;
        const amp = H * 0.06;

        // sampling density
        const step = 10; // px
        const points = [];
        for (let x = 0; x <= W; x += step) {
          // multiple sines -> organic wave
          const t = wavePhase;
          const n =
            Math.sin(t * 1.2 + x * 0.014) * 0.55 +
            Math.sin(t * 0.7 + x * 0.008) * 0.35 +
            Math.sin(t * 2.0 + x * 0.022) * 0.18;

          // spike zone
          const spikeCenter = W * 0.68;
          const d = Math.abs(x - spikeCenter);
          const spikeInfluence = Math.exp(-(d * d) / (2 * (W * 0.08) * (W * 0.08))) * spike;

          // final y
          const y = midY + n * amp - spikeInfluence * (H * 0.12);

          points.push({ x, y, spike: spikeInfluence });
        }

        // Under-glow (soft area)
        ctx.save();
        ctx.globalAlpha = Q.waveAlpha;
        ctx.globalCompositeOperation = 'lighter';

        ctx.beginPath();
        ctx.moveTo(points[0].x, points[0].y);
        for (let i = 1; i < points.length; i++) {
          ctx.lineTo(points[i].x, points[i].y);
        }
        ctx.lineTo(W, H);
        ctx.lineTo(0, H);
        ctx.closePath();

        const fill = ctx.createLinearGradient(0, midY, 0, H);
        fill.addColorStop(0, 'rgba(0,255,136,0.18)');
        fill.addColorStop(0.55, 'rgba(0,255,136,0.05)');
        fill.addColorStop(1, 'rgba(0,0,0,0)');
        ctx.fillStyle = fill;
        ctx.fill();
        ctx.restore();

        // Wave stroke (green)
        ctx.save();
        ctx.globalCompositeOperation = 'screen';
        ctx.lineWidth = 2;
        ctx.globalAlpha = 0.38;
        ctx.strokeStyle = 'rgba(0,255,136,0.9)';

        ctx.beginPath();
        ctx.moveTo(points[0].x, points[0].y);
        for (let i = 1; i < points.length; i++) {
          ctx.lineTo(points[i].x, points[i].y);
        }
        ctx.stroke();

        // highlight stroke (thin)
        ctx.lineWidth = 1;
        ctx.globalAlpha = 0.20;
        ctx.strokeStyle = 'rgba(255,255,255,0.55)';
        ctx.stroke();
        ctx.restore();

        // Red accent only when spike exists
        if (spike > 0.08) {
          ctx.save();
          ctx.globalCompositeOperation = 'screen';
          ctx.globalAlpha = clamp(spike * 0.30, 0, 0.22);
          ctx.strokeStyle = 'rgba(255,0,60,0.95)';
          ctx.lineWidth = 2;

          // draw only spike region
          ctx.beginPath();
          let started = false;
          for (const pt of points) {
            if (pt.spike > 0.02) {
              if (!started) {
                ctx.moveTo(pt.x, pt.y);
                started = true;
              } else {
                ctx.lineTo(pt.x, pt.y);
              }
            } else if (started) {
              break;
            }
          }
          ctx.stroke();
          ctx.restore();
        }
      }

      // ---------------------------------------------------------
      // Soft “scanline” sweep (rare, premium)
      // ---------------------------------------------------------
      let sweepT = rand(0, 10000);
      function drawSweep(dt) {
        sweepT += dt;
        // once in a while pass a faint diagonal light
        const period = 14000;
        const t = (sweepT % period) / period; // 0..1

        // only active near the middle of the cycle (keeps it rare)
        const active = Math.exp(-Math.pow((t - 0.55) / 0.10, 2));
        if (active < 0.04) return;

        ctx.save();
        ctx.globalCompositeOperation = 'screen';
        ctx.globalAlpha = active * 0.10;

        const x0 = -W * 0.2 + t * W * 1.4;
        const grad = ctx.createLinearGradient(x0, 0, x0 + W * 0.4, H);
        grad.addColorStop(0, 'rgba(0,0,0,0)');
        grad.addColorStop(0.45, 'rgba(0,255,136,0.10)');
        grad.addColorStop(0.55, 'rgba(255,0,60,0.06)');
        grad.addColorStop(1, 'rgba(0,0,0,0)');

        ctx.fillStyle = grad;
        ctx.fillRect(0, 0, W, H);

        ctx.restore();
      }

      // ---------------------------------------------------------
      // Frame loop with FPS cap
      // ---------------------------------------------------------
      let lastTime = now();
      let acc = 0;
      let frameCount = 0;
      let fps = 60;
      let fpsLast = now();

      function loop() {
        const t = now();
        let dt = t - lastTime;
        lastTime = t;

        // if reduced motion -> draw one frame and stop
        if (prefersReducedMotion) {
          drawBase();
          drawAurora(16);
          drawGrid();
          drawMarketWave(16);
          drawParticles(16);
          return;
        }

        // safety clamp
        dt = clamp(dt, 0, 48);

        // FPS cap (adaptive)
        const cap = Q.fpsCap;
        if (cap > 0) {
          const target = 1000 / cap;
          acc += dt;
          if (acc < target) {
            requestAnimationFrame(loop);
            return;
          }
          dt = acc;
          acc = 0;
        }

        // perf sampling
        frameCount++;
        if (t - fpsLast >= 1000) {
          fps = frameCount;
          frameCount = 0;
          fpsLast = t;

          // If FPS is low, reduce load gently
          if (fps < 45) {
            Q.particles = Math.max(25, Math.floor(Q.particles * 0.92));
            if (Q.blobs > 2) Q.blobs = 2;
            if (Q.fpsCap > 45) Q.fpsCap = 45;
          } else if (fps > 56) {
            // allow a bit more if stable (but keep it tasteful)
            Q.fpsCap = 60;
          }
        }

        // draw
        drawBase();
        drawAurora(dt);
        drawGrid();
        drawMarketWave(dt);
        drawParticles(dt);
        drawSweep(dt);

        requestAnimationFrame(loop);
      }

      // Start
      loop();

      // Rebuild after resize (keeps distribution nice)
      window.addEventListener('resize', () => {
        spawnParticles();
        spawnBlobs();
      });

    })();

  /* =========================================================
   Navigation Logic
   ========================================================= */

const container = document.querySelector('.container');
const originalContent = container.innerHTML;

function bindButtons() {
  const buttons = document.querySelectorAll('.btn');

  const startBtn = buttons[0];
  const aboutBtn = buttons[1];
  const supportBtn = buttons[2];

  if (supportBtn) {
    supportBtn.addEventListener('click', () => {
      const tg = window.Telegram?.WebApp;
      if (tg?.openTelegramLink) {
        tg.openTelegramLink('https://t.me/clivx');
      } else {
        window.open('https://t.me/clivx', '_blank');
      }
    });
  }

  if (aboutBtn) {
    aboutBtn.addEventListener('click', () => {
      container.innerHTML = `
        <div style="max-height:60vh; overflow-y:auto; padding-right:4px;">
          <div style="font-size:14px; line-height:1.6; opacity:.85; margin-bottom:30px;">
            Это не просто сигнальный бот — это полноценная система для тех,
            кто хочет работать с рынком осознанно и на результат.<br><br>

            Мы создали сильное комьюнити людей, объединённых одной целью —
            рост, дисциплина и финансовое развитие.<br><br>

            В рамках платной подписки участники получают:<br><br>

            — закрытый клуб с ежедневной аналитикой<br>
            — обучающие курсы и программу обучения<br>
            — ежедневные материалы и обновления<br>
            — личное сопровождение и поддержку<br><br>

            Сигнальный бот — лишь один из инструментов внутри системы.
            Главная ценность — знания, стратегия и сильное окружение.
          </div>

          <button class="btn" id="backBtn">Назад</button>
        </div>
      `;

      document.getElementById('backBtn').addEventListener('click', () => {
        container.innerHTML = originalContent;
        bindButtons(); // ← ПЕРЕПРИВЯЗКА
      });
    });
  }
}

bindButtons();
  </script>
</body>
</html>
